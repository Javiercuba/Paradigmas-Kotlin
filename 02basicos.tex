% Prof. Dr. Ausberto S. Castro Vera
% UENF - CCT - LCMAT - Curso de Ci\^{e}ncia da Computa\c{c}\~{a}o
% Campos, RJ,  2020
% Disciplina: Paradigmas de Linguagens de Programa\c{c}\~{a}o
% Aluno: Javier Ernesto


\chapterimage{img_superior} % Chapter heading image ==>  Trocar este arquivo por outro 1200x468
\chapter{ Conceitos b\'{a}sicos da Linguagem Kotlin}

Em Kotlin, tudo é um objeto no sentido de que 
podemos chamar funções e propriedades de membros
 em qualquer variável. Alguns tipos podem ter uma 
 representação interna especial - por exemplo, 
 números, caracteres e booleans podem ser 
 representados como valores primitivos no tempo 
 de execução, mas para o usuário eles se parecem
 com classes comuns.
    %%%%%%%%=================================

    \section{Vari\'{a}veis e constantes}
      As variáveis em Kotlin podem ser facilmente 
    definidas como mutáveis (var) ou imutáveis (val).
    A ideia é muito semelhante ao uso "final" em variáveis Java.
    Mas a imutabilidade é um conceito muito importante em Kotlin (e muitas outras línguas modernas).
   
    Um objeto imutável é um objeto cujo estado não pode mudar 
    após a instanciação. Se você precisar de uma versão 
    modificada do objeto, um novo objeto precisa ser criado.
    Isso torna a programação muito mais robusta e previsível. 
    Em Java, a maioria dos objetos são mutáveis, o que significa
    que qualquer parte do código que tenha acesso ao objeto pode 
    modificá-lo, afetando o resto do aplicativo.

    Assim, a maneira como pensamos sobre codificação muda um pouco em Kotlin 
    se quisermos fazer uso da imutabilidade. O conceito-chave: basta usar 
    val tanto quanto possível. Haverá situações (especialmente no Android,
    onde não temos acesso ao construtor de muitas classes) onde não será 
    possível, mas será na maioria das vezes

    Outro ponto é que geralmente não precisamos 
    especificar tipos de objetos, eles serão inferidos a partir do 
    valor, o que torna o código mais limpo e mais rápido para ser modificado.
    \begin{lstlisting}
      val numero = 1 // Inteiro
      val nome = "Exemplo" // String  
    \end{lstlisting}


\section{Tipos de Dados B\'{a}sicos}
    %%%%%%%%=================================
         
 \lipsum[2]
  \subsection{Tipos Inteiros}
  Kotlin fornece um conjunto de tipos embutidos que representam números.
  Para números inteiros, existem quatro tipos com tamanhos diferentes e, portanto, faixas de valor.
    \begin{table}[ht]
      \centering
      
      \begin{tabular}{|p{2cm} p{1.5cm} p{6.0cm} p{6.0cm}| cp{2cm}}
      \hline
      \textbf{Tipo} \centering & \textbf{Size(Bits)} & \textbf{Valor mínimo} & \textbf{Valor máximo} \\ \hline
          Byte \centering    & 8  \centering  & -128   & 127                 \\ 
          Short \centering  & 16  \centering & -32768   & 32767             \\ 
          Int \centering    & 32  \centering &  -2,147,483,648 ($-2 ^{31}$)      &2,147,483,648 ($2^{31}-1$)            \\ 
          Long \centering    & 32  \centering &  -9,223,372,036,854,775,808 ($-2 ^{63}$)      &9,223,372,036,854,775,808 ($2^{63}$)              \\ \hline
      
      \end{tabular}
      \label{Tabela1}
      \end{table}
      Todas as variáveis inicializadas com valores inteiros não excedem o valor 
      máximo de ter o tipo inferido . Se o valor inicial exceder esse valor, 
      então o tipo será . Para especificar o valor explicitamente, apendice o sufixo ao valor.
     
            %%%........................

    C\'{o}digo fonte para a linguagem Kotlin:
    \begin{lstlisting}
      val one = 1 // Int
      val threeBillion = 3000000000 // Long
      val oneLong = 1L // Long
      val oneByte: Byte = 1
  
    \end{lstlisting}

    \begin{lstlisting}
  class Rational(n: Int, d: Int) {

    require(d != 0)

    private val g = gcd(n.abs, d.abs)
    val numer = n / g
    val denom = d / g

    def this(n: Int) = this(n, 1)

    def + (that: Rational): Rational =
      new Rational(
        numer * that.denom + that.numer * denom,
        denom * that.denom
      )

    def + (i: Int): Rational =
      new Rational(numer + i * denom, denom)

    def - (that: Rational): Rational =
      new Rational(
        numer * that.denom - that.numer * denom,
        denom * that.denom
      )
    \end{lstlisting}
    %%%%%%%%=================================
    \section{Operadores e Express\~{o}es em Scala}
    %%%%%%%%=================================


